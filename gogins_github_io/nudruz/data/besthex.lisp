(in-package :cm)

;; BESTHEX -- all unsorted first hexachords that will have a
;; hexachorally-related inversion 
;; (when paired with complementary hexachord to make a complete row)

;; building 'besthex':
;(no-nils
; (loop for thex in 
;       (mapcar (lambda (x) (cons 0 x))
;	       (subsets-len (indices 11 1) 5))
;       collect
;       (if (member (otherhex thex) 
;		   (alltransp (mod12 (mapcar (lambda (n) (- 12 n)) thex))) 
;		   :test #'list-eql)
;	   thex)))

(defparameter besthex
    '((0 1 2 3 4 5) (0 1 2 3 4 6) (0 1 2 3 4 10) (0 1 2 3 4 11) (0 1 2 3 5 7)
      (0 1 2 3 5 10) (0 1 2 3 5 11) (0 1 2 3 6 7) (0 1 2 3 8 9) (0 1 2 3 8 10)
      (0 1 2 3 9 11) (0 1 2 3 10 11) (0 1 2 4 5 8) (0 1 2 4 6 8) (0 1 2 4 6 10)
      (0 1 2 4 6 11) (0 1 2 4 8 9) (0 1 2 4 8 10) (0 1 2 4 9 11) (0 1 2 4 10 11)
      (0 1 2 5 6 10) (0 1 2 5 6 11) (0 1 2 5 7 8) (0 1 2 6 7 8) (0 1 2 6 7 9)
      (0 1 2 6 8 10) (0 1 2 6 9 10) (0 1 2 7 8 11) (0 1 2 7 9 11) (0 1 2 8 10 11)
      (0 1 2 9 10 11) (0 1 3 4 5 9) (0 1 3 4 6 9) (0 1 3 4 7 10) (0 1 3 4 7 11)
      (0 1 3 5 7 9) (0 1 3 5 7 10) (0 1 3 5 7 11) (0 1 3 5 8 9) (0 1 3 5 8 10)
      (0 1 3 5 9 11) (0 1 3 5 10 11) (0 1 3 6 7 8) (0 1 3 6 7 9) (0 1 3 6 8 10)
      (0 1 3 6 9 10) (0 1 3 7 8 11) (0 1 3 7 9 11) (0 1 3 8 10 11)
      (0 1 3 9 10 11) (0 1 4 5 6 7) (0 1 4 5 6 8) (0 1 4 5 7 9) (0 1 4 5 8 9)
      (0 1 4 5 8 10) (0 1 4 5 9 11) (0 1 4 5 10 11) (0 1 4 6 7 10) (0 1 4 6 7 11)
      (0 1 4 6 8 9) (0 1 4 6 8 10) (0 1 4 7 9 10) (0 1 4 8 9 10) (0 1 5 6 7 10)
      (0 1 5 6 7 11) (0 1 5 6 8 11) (0 1 5 7 8 9) (0 1 5 7 9 11) (0 1 5 8 9 11)
      (0 1 6 7 8 9) (0 1 6 7 10 11) (0 1 6 8 10 11) (0 1 7 9 10 11)
      (0 1 8 9 10 11) (0 2 3 4 5 6) (0 2 3 4 5 7) (0 2 3 4 5 10) (0 2 3 4 6 8)
      (0 2 3 4 6 10) (0 2 3 4 7 8) (0 2 3 4 8 10) (0 2 3 4 8 11) (0 2 3 5 6 9)
      (0 2 3 5 7 9) (0 2 3 5 7 10) (0 2 3 5 8 10) (0 2 3 5 8 11) (0 2 3 6 7 10)
      (0 2 3 6 8 9) (0 2 3 6 8 10) (0 2 3 6 9 11) (0 2 3 6 10 11) (0 2 3 7 8 9)
      (0 2 4 5 6 7) (0 2 4 5 6 8) (0 2 4 5 6 10) (0 2 4 5 7 9) (0 2 4 5 7 10)
      (0 2 4 5 8 9) (0 2 4 5 8 10) (0 2 4 6 7 8) (0 2 4 6 7 9) (0 2 4 6 7 10)
      (0 2 4 6 8 9) (0 2 4 6 8 10) (0 2 4 6 8 11) (0 2 4 6 9 10) (0 2 4 6 9 11)
      (0 2 4 6 10 11) (0 2 4 7 8 10) (0 2 4 7 8 11) (0 2 4 7 9 10) (0 2 4 7 9 11)
      (0 2 4 8 9 10) (0 2 4 8 10 11) (0 2 4 9 10 11) (0 2 5 6 7 11)
      (0 2 5 6 8 10) (0 2 5 6 8 11) (0 2 5 6 9 10) (0 2 5 7 8 10) (0 2 5 7 9 10)
      (0 2 5 7 9 11) (0 2 5 8 9 11) (0 2 6 7 8 10) (0 2 6 7 10 11) (0 2 6 8 9 10)
      (0 2 6 8 10 11) (0 2 7 8 9 10) (0 2 7 9 10 11) (0 2 8 9 10 11)
      (0 3 4 5 6 11) (0 3 4 5 7 11) (0 3 4 5 9 10) (0 3 4 6 7 8) (0 3 4 6 7 9)
      (0 3 4 6 8 10) (0 3 4 6 8 11) (0 3 4 6 9 10) (0 3 4 7 8 10) (0 3 4 7 8 11)
      (0 3 4 7 9 11) (0 3 4 8 10 11) (0 3 4 9 10 11) (0 3 5 6 8 9) (0 3 5 6 8 10)
      (0 3 5 6 9 11) (0 3 5 6 10 11) (0 3 5 7 8 10) (0 3 5 7 8 11) (0 3 5 7 9 10)
      (0 3 5 7 9 11) (0 3 6 7 9 10) (0 3 6 8 9 11) (0 3 7 8 9 11) (0 4 5 6 8 9)
      (0 4 5 6 8 10) (0 4 5 6 9 11) (0 4 5 6 10 11) (0 4 5 7 10 11)
      (0 4 5 8 9 10) (0 4 6 7 8 10) (0 4 6 7 8 11) (0 4 6 8 9 10) (0 4 6 8 10 11)
      (0 4 7 8 10 11) (0 5 6 7 8 10) (0 5 6 7 8 11) (0 5 6 9 10 11)
      (0 5 7 8 9 10) (0 5 7 9 10 11) (0 6 7 8 9 10) (0 6 8 9 10 11)
      (0 7 8 9 10 11)))


;; YIKES! TRICHORD QUALITY NOT NEC. TRUE FOR COMPLEMENT!
;; 'besthextri' test for trichords with common normal forms 
;(remove-duplicates
; (filter (lambda (x) (seq-eql (prime-form (subseq x 0 3))
;			      (prime-form (subseq x 3 6))))
;	 (flatter	
;	  (mapcar #'permutations
;		  besthex)))
; :test #'seq-eql)


