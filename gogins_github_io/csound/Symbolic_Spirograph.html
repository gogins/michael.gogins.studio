<!DOCTYPE html>
<html>
    <head>
        <title>Symbolic Math Example</title>
        <script type="text/javascript" src="silencio/js/dat.gui.js"></script>
        <script type="text/javascript" src="silencio/js/jquery.js"></script>
        <script type="text/javascript" src="silencio/js/Silencio.js"></script>
        <script type="text/javascript" src="silencio/js/ChordSpace.js"></script>
        <script type="text/javascript" src="silencio/js/sprintf.js"></script>
        <script type="text/javascript" src="silencio/js/three.js"></script>
        <script type="text/javascript" src="silencio/js/TrackballControls.js"></script>
        <script type='text/javascript' src='silencio/js/tinycolor.js'></script>
        <script type='text/javascript' src='silencio/js/numeric.js'></script>
        <script type='text/javascript' src='silencio/js/algebrite.bundle-for-browser.js'></script>
        <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
        <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
        <meta http-equiv="Pragma" content="no-cache" />
        <meta http-equiv="Expires" content="0" />
        <script>
        try {
            var csound = require('csound.node');
            console.log('csound:', csound);
            //var fs = require('fs');
            var nwgui = require('nw.gui');
            var nw_window = nwgui.Window.get();
            nw_window.on('close', function() {
                console.log('Closing down...');
                this.close(true);
                //process.exit(0);
            });
        } catch (err) {
            alert(err);
            console.log(err.message);
        }
    </script>
    </head>
    <body style="background:black;">
    <style>
            ::-webkit-scrollbar
        {
            width:10px;
        }
        ::-webkit-scrollbar-track-piece
        {
            background-coor:transparent;
        }
    </style>
    <canvas id = 'graphics_canvas' class='canvas' style="width:98vw;height:98vh;"></canvas>
    <table id = 'statistics' style="table-layout:fixed;position:absolute;left:1vw;color:#eee;top:1vw;font-family:Monaco, sans-serif;font-size:8pt">
            <col style="width:300px">
            <col style="width:150px">
        <tr style="color:gold;font-size:14px;">
            <!-- Copyright (C) 2016 by Michael Gogins -->
            <td style="font-weight:bold;"><b><i>Spirograph</i></b> for csound.node</td>
            <td style="color:gold;text-align:right;">Michael Gogins</td>
        </tr>
        <tr>
            <td colspan="2" style="color:gold;text-align:left">Click "Play"; adjust "Master effects" group "gk_MasterOutput_level" slider.</td>
        </tr>
        <tr style="font-size:14px;">
            <td>Time:</td>
            <td id="Time_cell" style="text-align:right;color:LawnGreen;font-weight:bold;">0</td>
        </tr>
        <tr>
            <td colspan="2">This piece generates a score from a simple spirograph using the <a href='http://algebrite.org/'>Algebrite</a> symbolic algebra library to "plot" the parametric equation of the spirograph as notes, with parameters controlled by the composer. The disk containing the spirograph is then mapped to a square using the elliptical grid map from <a href='https://arxiv.org/pdf/1509.06344.pdf'>Chamberlain Fong, <b><i>Analytical Methods for Squaring the Disc</b></i></a>, which is then remapped to the rectangle containing the score.
            </td>
        </tr>
        <tr>
            <td colspan="2">Symbolic math in JavaScript has pros and cons. Pros: Save on writing code by writing equations; smaller chance of logic or coding errors; can be easier to find cool equations than cool code; equations can be controlled parametrically for interactive composition. Cons: Runs somewhat slower than code. The parametric equations for the spirograph are:
            </td>
        </tr>
        <tr id=eq_1>
            <td colspan="2">equation 1
            </td>
        </tr>
        <tr>
            <td colspan="2">The disk to square mapping is:
            </td>
        </tr>
        <tr id=eq_2>
            <td colspan="2">equation 2
            </td>
        </tr>
        <tr>
            <!-- or: http://stackoverflow.com/questions/35509360/how-to-make-the-content-of-the-following-table-cell-scrollable -->
            <td colspan="2"><textarea id="Log_cell" style="color:SkyBlue;background-color:transparent;border:none;text-align:left;font-size:10px;height:200px;width:550px;overflow:auto;"></textarea></td>
        </tr>
    </table>
     <textarea class="code" id="orc" hidden rows=24 cols=80>

sr = 88200
ksmps = 200
nchnls = 2
0dbfs = 1500000

connect "FM_Clang", "outleft", "ReverbLeft", "inleft"
connect "FM_Clang", "outright", "ReverbRight", "inright"
connect "Blower", "outleft", "ReverbLeft", "inleft"
connect "Blower", "outright", "ReverbRight", "inright"
connect "Bower", "outleft", "ReverbLeft", "inleft"
connect "Bower", "outright", "ReverbRight", "inright"
connect "Buzzer", "outleft", "ReverbLeft", "inleft"
connect "Buzzer", "outright", "ReverbRight", "inright"
connect "Droner", "outleft", "ReverbLeft", "inleft"
connect "Droner", "outright", "ReverbRight", "inright"
connect "Harpsichord", "outleft", "Reverb2Left", "inleft"
connect "Harpsichord", "outright", "Reverb2Right", "inright"
connect "Phaser", "outleft", "ReverbLeft", "inleft"
connect "Phaser", "outright", "ReverbRight", "inright"
connect "PianoOut", "outleft", "MasterOutput", "inleft"
connect "PianoOut", "outright", "MasterOutput", "inright"
connect "PianoOut", "outleft", "Reverb2Left", "inleft"
connect "PianoOut", "outright", "Reverb2Right", "inright"
connect "Sweeper", "outleft", "ReverbLeft", "inleft"
connect "Sweeper", "outright", "ReverbRight", "inright"
connect "Shiner", "outleft", "ReverbLeft", "inleft"
connect "Shiner", "outright", "ReverbRight", "inright"
connect "YiString", "outleft", "ReverbLeft", "inleft"
connect "YiString", "outright", "ReverbRight", "inright"
connect "YiString", "chorusleft", "SolinaChorus", "inleft"
connect "YiString", "chorusright", "SolinaChorus", "inright"
connect "SolinaChorus", "outleft", "ReverbLeft", "inleft"
connect "SolinaChorus", "outright", "ReverbRight", "inright"
connect "ReverbLeft", "outleft", "MasterOutput", "inleft"
connect "ReverbRight", "outright", "MasterOutput", "inright"
connect "Reverb2Left", "outleft", "MasterOutput", "inleft"
connect "Reverb2Right", "outright", "MasterOutput", "inright"

alwayson "FM_Clang_controls"
alwayson "Controls"
alwayson "PianoOut"
alwayson "SolinaChorus"
alwayson "ReverbLeft"
alwayson "ReverbRight"
alwayson "Reverb2Left"
alwayson "Reverb2Right"
alwayson "FM_Clang_preset"
alwayson "ParametricEQ"
alwayson "MasterOutput"

gk_overlap init .25

gaSendM,gaSendL,gaSendR init 0
gi_FM_Clang_sine ftgen 0,0,4096,10,1 ;A SINE WAVE. USED BY THE LFOs.
gi_FM_Clang_detuning ftgen 0,0,128,21,1,1 ; random array used for fixing unique detune values for each note
gi_FM_Clang_DryMap ftgen 0,0,4096,7,1,2048,1,2048,0 ; dry mixer control mapping
gi_FM_Clang_WetMap ftgen 0,0,4096,7,0,2048,1,2048,1 ; wet mixer control mapping
gaSendL,gaSendR init 0 ; initialise variable used for sending audio between instruments
gi_FM_Clang_Imp ftgen 0,0,4097,9,0.5,1,0 ; shape for the hammer inpulse
gi_FM_Clang_stereo ftgen 0,0,256,21,1,1 ; random array used for fixing unique stereo values for each note
gi_FM_Clang_detune ftgen 0,0,256,21,1,1 ; random array used for fixing unique detune values for each note
gi_FM_Clang_scale ftgen 0,0,128,-7,-1,128,1

instr FM_Clang_controls ; Read in widgets
iporttime = 0.05
gk_FM_Clang_mod chnget "mod"
gk_FM_Clang_mod port gk_FM_Clang_mod,iporttime
gk_FM_Clang_NdxVel chnget "NdxVel"
gk_FM_Clang_Dur chnget "Dur"
gk_FM_Clang_FiltFund chnget "FiltFund"
gk_FM_Clang_NdxCurve chnget "NdxCurve"
gk_FM_Clang_LPF chnget "LPF"
gk_FM_Clang_ModDep chnget "ModDep"
gk_FM_Clang_ModRte chnget "ModRte"
gk_FM_Clang_ModRteKyb chnget "ModRteKyb"
gk_FM_Clang_ModMix chnget "ModMix"
gk_FM_Clang_Sustain chnget "Sustain"
gk_FM_Clang_CarKyb chnget "CarKyb"
gk_FM_Clang_StWidth chnget "StWidth"
gk_FM_Clang_StWidth init 0.01
gk_FM_Clang_StMix chnget "StMix"
gk_FM_Clang_DryWet chnget "RvbDryWet"
gk_FM_Clang_Dry table gk_FM_Clang_DryWet,gi_FM_Clang_DryMap,1 ; map dry/wet control
gk_FM_Clang_Wet table gk_FM_Clang_DryWet,gi_FM_Clang_WetMap,1 ;
gk_FM_Clang_RvbSize chnget "RvbSize"
gk_FM_Clang_Detune chnget "Detune"
gk_FM_Clang_DtnMix chnget "DtnMix"
gk_FM_Clang_Amp chnget "Amp"
gk_FM_Clang_level chnget "gk_FM_Clang_level"
gk_FM_Clang_Amp port gk_FM_Clang_Amp,iporttime
gk_FM_Clang_AttTim chnget "AttTim"
gk_FM_Clang_AttVel chnget "AttVel"
gk_FM_Clang_NseAmp chnget "NseAmp"
gk_FM_Clang_NseBW chnget "NseBW"
gk_FM_Clang_NseFllw chnget "NseFllw"
endin

gi_OS_Windows init 1
giPianoteq init 0
giFluidsynth init 0
giFluidSteinway init 0

instr PianoNote
i_instrument = p1
i_time = p2
i_duration = p3
i_midikey = p4
i_midivelocity = p5
i_phase = p6
i_pan = p7
i_depth = p8
i_height = p9
i_pitchclassset = p10
i_homogeneity = p11
; Use channel assigned in fluidLoad.
ichannel = 0
;;;;;;;;;;;;;;;;;;;;i
prints "FlSteinway  i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
fluidNote giFluidsynth, ichannel, i_midikey, i_midivelocity
endin

gk_Harpsichord_level init .25
gk_Harpsichord_pick init .75
gk_Harpsichord_reflection init .5
gk_Harpsichord_pluck init .75
instr Harpsichord
insno 		 = p1
itime 		 = p2
iduration 		 = p3
ikey 		 = p4
ivelocity = p5
iphase = p6
ipan = p7
idepth = p8
iheight = p9
ipcs = p10
ihomogeneity = p11
gk_Harpsichord_pan = .5
iattack = .005
isustain = p3
irelease = .3
p3 = iattack + isustain + irelease
iHz = cpsmidinn(ikey)
kHz = k(iHz)
iamplitude = ampdb(ivelocity) * 10
aenvelope 	 transeg 1.0, 20.0, -10.0, 0.05
;apluck 	 pluck 1, kHz, iHz, 0, 1
;apluck 	 pluck 1, kHz, iHz, 0, 6
k_amplitude = 1
apluck wgpluck2 i(gk_Harpsichord_pluck), k_amplitude, iHz, gk_Harpsichord_pick, gk_Harpsichord_reflection
iharptable 	 ftgenonce 0, 0, 65536, 7, -1, 1024, 1, 1024, -1
aharp 	 poscil 1, kHz, iharptable
aharp2 	 balance apluck, aharp
asignal	= (apluck + aharp2) * iamplitude * aenvelope * gk_Harpsichord_level
adeclick linsegr 0, iattack, 1, isustain, 1, irelease, 0
asignal = asignal * adeclick
aleft, aright pan2 asignal, ipan
kgain = ampdb(gk_Harpsichord_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;ikgain = ampdb(gk_Bower_level)

prints "Harpsichord i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

opcode FM_Clang_veloc, i, iii
; *p->r = *p->ilo + csound->curip->m_veloc*(*p->ihi - *p->ilo) * dv127;
ivel, ilow, ihigh xin
xout ilow + ivel * (ihigh - ilow) * 0.007874
endop

gk_FM_Clang_level init 0
instr FM_Clang ; Sound producing instrument. Triggered by MIDI notes or score notes.
//////////////////////////////////////////////
// Original by Iain McCurdy.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
kgain init 1
insno = p1
itime = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
idepth = p8
iheight = p9
ipcs = p10
ihomogeneity = p11
icps = cpsmidinn(ikey)
inum = ikey
iamplitude = ampdb(ivelocity)
; icps cpsmidi
; inum notnum
iKybdScl table inum,gi_FM_Clang_scale ; Keyboard scaling value. Note '0' maps to a value of -1, note 64 maps to a value of zero and note 127 maps to a value of 1.
; Amplitude Envelope
idur = i(gk_FM_Clang_Dur)
iAmpCurve = -8
iRelTim = (i(gk_FM_Clang_Sustain)==1?idur:0.1)
;iAttVel veloc i(gk_FM_Clang_AttVel)*0.05,0
iAttVel FM_Clang_veloc ivelocity, i(gk_FM_Clang_AttVel)*0.05,0
iAttTim = iAttVel + i(gk_FM_Clang_AttTim)
if iAttTim==0 then
aAEnv transegr 1,idur,iAmpCurve,0, iRelTim,iAmpCurve,0
else
aAEnv transegr 0,iAttTim,iAmpCurve, 1,idur,iAmpCurve,0, iRelTim,iAmpCurve,0
endif
; Key velocity to amplitude
;iAVel veloc 0,0.1
iAVel FM_Clang_veloc ivelocity, 0, 0.1
; FM index
iNdx veloc 0,i(gk_FM_Clang_NdxVel) ; Key velocity to FM index
iNdx FM_Clang_veloc ivelocity, 0,i(gk_FM_Clang_NdxVel) ; Key velocity to FM index
kIEnv transeg iNdx*octave(-iKybdScl*4),idur,-i(gk_FM_Clang_NdxCurve),0 ; Index envelope. Amplitude influenced by 'Index' widget control and keyboard scaling (index reduced for higher notes, increased for lower notes)
; Carrier frequency keyboard scaling
icar = 1 * octave(iKybdScl*i(gk_FM_Clang_CarKyb))
; Carrier ratio modulation
iModRte table inum,gi_FM_Clang_scale
iModRte = octave(iModRte*i(gk_FM_Clang_ModRteKyb))
kDepEnv transeg 1,idur,-4,0
amod lfo gk_FM_Clang_ModDep*0.1*kDepEnv, gk_FM_Clang_ModRte * iModRte, 0
; Noise bandpass filter cutoff as it respond to the 'Carrier Follow' switch
kcf = gk_FM_Clang_NseFllw==1?icps*gk_FM_Clang_mod:icps
; Noise amplitude keyboard following
kNseAmp = octave(iKybdScl*-4)*gk_FM_Clang_NseAmp
; Main FM algorithm
if gk_FM_Clang_NseAmp>0 then ; If noise amplitude is greater than zero...
aNse gauss kNseAmp ; ... generate some gaussian noise
aNse butbp aNse,kcf,kcf*gk_FM_Clang_NseBW ; bandpass filter the noise
aNse butbp aNse,kcf,kcf*gk_FM_Clang_NseBW ; and again
else
aNse = 0 ; Otherwise no noise signal!
endif
idetune table inum,gi_FM_Clang_detune ; Read a detuning value from a random table
asig foscil iAVel, icps*cent(-gk_FM_Clang_Detune*idetune), icar +aNse, gk_FM_Clang_mod, kIEnv, gi_FM_Clang_sine ; FM pair
aModSig foscil iAVel, icps*cent(-gk_FM_Clang_Detune*idetune), icar+amod+aNse, gk_FM_Clang_mod, kIEnv, gi_FM_Clang_sine ; FM pair with modulation
asig = asig + (aModSig * gk_FM_Clang_ModMix) ; Mix the two FM pairs.
; Auxilliary FM algorithm (used for detuning)
if gk_FM_Clang_DtnMix>0&&gk_FM_Clang_Detune>0 then
if gk_FM_Clang_NseAmp>0 then
aNse gauss kNseAmp
aNse butbp aNse,kcf,kcf*gk_FM_Clang_NseBW
aNse butbp aNse,kcf,kcf*gk_FM_Clang_NseBW
else
aNse = 0
endif

idetune table inum+128,gi_FM_Clang_detune ; Read a detuning value from a random table
asig2 foscil iAVel, icps*cent(gk_FM_Clang_Detune*idetune), icar +aNse, gk_FM_Clang_mod, kIEnv, gi_FM_Clang_sine ; Detuning applied to fundemental
aModSig2 foscil iAVel, icps*cent(gk_FM_Clang_Detune*idetune), icar+amod+aNse, gk_FM_Clang_mod, kIEnv, gi_FM_Clang_sine
asig2 = asig2 + (aModSig2 * gk_FM_Clang_ModMix)
asig = asig + asig2*gk_FM_Clang_DtnMix
endif
; Filter Fundemental
if i(gk_FM_Clang_FiltFund)==1 then ; If filter fundemental switch is active
asig butbr asig,icps*icar,icps*icar*0.3 ; Filter out fundemental
asig butbr asig,icps*icar,icps*icar*0.3 ; and again to make sure it is all gone
endif
; Lowpass Filter
if i(gk_FM_Clang_LPF)<32 then ; If lowpass filter is less than maximum...
kCF limit icps*gk_FM_Clang_LPF,20,20000 ; ...create the cutoff value in CPS based on fundemental and LPF ratio control. Limit to prevent out of range values.
asig clfilt asig,kCF,0,2 ; Butterworth lowpass filter
endif
; Amplitude Envelope
kgain = ampdb(gk_FM_Clang_level)
asig = asig * aAEnv * gk_FM_Clang_Amp * kgain; Apply amplitude envelope
; Stereo Effect
iDlyTimL table inum,gi_FM_Clang_stereo ; Read a delay time value from a random table based on note played
iDlyTimR table inum+128,gi_FM_Clang_stereo ; Read a different delay time value from a random table based on note played
if gk_FM_Clang_StWidth>0&&gk_FM_Clang_StMix>0 then ; If 'width' is above zero and 'mix' is above zero...
aL vdelay asig, iDlyTimL*gk_FM_Clang_StWidth*1000, 0.2*1000 ; ...left channel delay
aR vdelay asig, iDlyTimR*gk_FM_Clang_StWidth*1000, 0.2*1000 ; right channel delay
aL ntrpol asig, aL, gk_FM_Clang_StMix ; Mix delayed and dry signal
aR ntrpol asig, aR, gk_FM_Clang_StMix ;
aleft = aL;*gk_FM_Clang_Dry
aright = aR;*gk_FM_Clang_Dry
gaSendL = gaSendL + aL ; Send to reverb
gaSendR = gaSendR + aR
else
aleft = asig;*gk_FM_Clang_Dry
aright = asig;*gk_FM_Clang_Dry
gaSendL = gaSendL + asig ; Send to reverb
gaSendR = gaSendR + asig
endif
aleft1 = aleft * ampdb(ivelocity)
aright1 = aright * ampdb(ivelocity)
asignal = (aleft1 + aright1) *100
aleft2, aright2 pan2 asignal, ipan
outleta "outleft", aleft2 * kgain
outleta "outright", aright2 * kgain
prints "FM_Clang    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Bower_level init 0.5
gk_Bower_pressure init 0.25
instr Bower
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 100
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
kamp = kenvelope
kfreq = ihertz
kpres = 0.25
krat rspline 0.006,0.988,1,4
kvibf = 4.5
kvibamp = 0
iminfreq = 30
isine ftgenonce 0,0,65536,10,1
aSig wgbow kamp,kfreq,gk_Bower_pressure,krat,kvibf,kvibamp,isine,iminfreq
aleft, aright pan2 aSig / 7, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Bower_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "Bower       i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Phaser_ratio1 init 1
gk_Phaser_ratio2 init 1/3
gk_Phaser_index1 init 1
gk_Phaser_index2 init 0.0125
gk_Phaser_level init 0.5
instr Phaser
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 8
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
isine ftgenonce 0,0,65536,10,1
khertz = ihertz
ifunction1 = isine
ifunction2 = isine
a1,a2 crosspm gk_Phaser_ratio1, gk_Phaser_ratio2, gk_Phaser_index1, gk_Phaser_index2, khertz, ifunction1, ifunction2
aleft, aright pan2 a1+a2, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft * kenvelope
aright = adamping * aright * kenvelope
kgain = ampdb(gk_Phaser_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "Phaser      i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_YiString_level init 1
gk_YiString_reverb_send init .5
gk_YiString_chorus_send init .5
instr YiString
 //////////////////////////////////////////////
 // Original by Steven Yi.
 // Adapted by Michael Gogins.
 //////////////////////////////////////////////
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) *16
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
aenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
;ampenv = madsr:a(1, 0.1, 0.95, 0.5)
asignal = vco2(1, ihertz)
asignal = moogladder(asignal, 6000, 0.1)
asignal *= aenvelope
aleft, aright pan2 asignal, ipan
kgain = ampdb(gk_YiString_level)
outleta "outleft", aleft * kgain * gk_YiString_reverb_send
outleta "outright", aright * kgain * gk_YiString_reverb_send
outleta "chorusleft", aleft * kgain * gk_YiString_chorus_send
outleta "chorusright", aright * kgain * gk_YiString_chorus_send
;;;;;;;;;;;;;;;;;;;;i
prints "YiString    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Droner_partial1 init .1
gk_Droner_partial2 init .1
gk_Droner_partial3 init .1
gk_Droner_partial4 init .1
gk_Droner_partial5 init .1
gk_Droner_level init 0.5
instr Droner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
k1 init .5
k2 init .05
k3 init .1
k4 init .2
k5 init .1
k6 init .05
k7 init .1
k8 init 0
k9 init 0
k10 init 0
k3 = gk_Droner_partial1
k4 = gk_Droner_partial2
k5 = gk_Droner_partial3
k6 = gk_Droner_partial4
k7 = gk_Droner_partial5
kwaveform init 0
iamp = ampdb(ivelocity)
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
isine ftgenonce 0, 0, 65536, 10, 1, 0, .02
if kwaveform == 0 then
asignal poscil3 1, ihertz, isine
endif
if kwaveform == 1 then
asignal vco2 1, ihertz, 8 ; integrated saw
endif
if kwaveform == 2 then
asignal vco2 1, ihertz, 12 ; triangle
endif
asignal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
asignal = asignal * kenvelope * 10
aleft, aright pan2 asignal, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Droner_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "Droner      i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Sweeper_britel init 0
gk_Sweeper_briteh init 2.9
gk_Sweeper_britels init .2 / 3
gk_Sweeper_britehs init 2.5 / 2
gk_Sweeper_level init 0.5
instr Sweeper
//////////////////////////////////////////////
// Original by Iain McCurdy.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity)
gisine ftgenonce 0, 0, 65536, 10, 1
gioctfn ftgenonce 0, 0, 65536, -19, 1, 0.5, 270, 0.5
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
icps = ihertz
kamp expseg 0.001,0.02,0.2,p3-0.01,0.001
ktonemoddep jspline 0.01,0.05,0.2
ktonemodrte jspline 6,0.1,0.2
ktone poscil3 ktonemoddep, ktonemodrte, gisine
kbrite rspline gk_Sweeper_britel, gk_Sweeper_briteh, gk_Sweeper_britels, gk_Sweeper_britehs
ibasfreq init icps
ioctcnt init 3
iphs init 0
a1 hsboscil kenvelope, ktone, kbrite, ibasfreq, gisine, gioctfn, ioctcnt, iphs
amod poscil3 0.25, ibasfreq*(1/3), gisine
arm = a1*amod
kmix expseg 0.001, 0.01, rnd(1), rnd(3)+0.3, 0.001
kmix=.25
a1 ntrpol a1, arm, kmix
;a1 pareq a1/10, 400, 15, .707
;a1 tone a1, 500
kpanrte jspline 5, 0.05, 0.1
kpandep jspline 0.9, 0.2, 0.4
kpan poscil3 kpandep, kpanrte, gisine
a1,a2 pan2 a1, kpan
a1 delay a1, rnd(0.1)
a2 delay a2, rnd(0.11)
kenv linsegr 1, 1, 0
kenv = kenvelope
aleft = a1*kenv*.02
aright = a2*kenv*.02
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Sweeper_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "Sweeper     i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Buzzer_Harmonics init 15
gk_Buzzer_level init .5
instr Buzzer
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
;asignal gbuzz kenvelope, ihertz, 3, gk_FirstHarmonic, gk_DistortFactor, gisine
isine ftgenonce 0, 0, 65536, 10, 1
gk_Harmonics = gk_Buzzer_Harmonics
asignal buzz kenvelope, ihertz, gk_Harmonics, isine
asignal = asignal * 3
;asignal vco2 kenvelope, ihertz, 12
;asignal poscil3 kenvelope, ihertz, giharmonics
;asignal distort asignal, gk_DistortFactor * .4, giwaveshaping
aleft, aright pan2 asignal, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Buzzer_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "Buzzer      i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Shiner_level init 0.5
instr Shiner
insno = p1
istart = p2
iduration = p3
ikey = p4
ivelocity = p5
iphase = p6
ipan = p7
iamp = ampdb(ivelocity) * 4
iattack = i(gk_overlap)
idecay = i(gk_overlap)
isustain = p3 - i(gk_overlap)
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(ikey)
gk_Harmonics = 1 * 20
asignal vco2 kenvelope * 4, ihertz, 12
aleft, aright pan2 asignal, ipan
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Shiner_level)
;printks2 "master gain:", kgain
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "Shiner      i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Blower_grainDensity init 150
gk_Blower_grainDuration init 0.2
gk_Blower_grainAmplitudeRange init 100
gk_Blower_grainFrequencyRange init .033
gk_Blower_level init 0.5
instr Blower
 //////////////////////////////////////////////
 // Original by Hans Mikelson.
 // Adapted by Michael Gogins.
 //////////////////////////////////////////////
i_time = p2
i_duration = p3
i_midikey = p4
i_midivelocity = p5
i_phase = p6
i_pan = p6
i_depth = p8
i_height = p9
i_pitchclassset = p10
i_homogeneity = p11
ifrequency = cpsmidinn(i_midikey)
iamplitude = ampdb(i_midivelocity) / 200
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ; f1 0 65536 1 "hahaha.aif" 0 4 0
 ; f2 0 1024 7 0 224 1 800 0
 ; f3 0 8192 7 1 8192 -1
 ; f4 0 1024 7 0 512 1 512 0
 ; f5 0 1024 10 1 .3 .1 0 .2 .02 0 .1 .04
 ; f6 0 1024 10 1 0 .5 0 .33 0 .25 0 .2 0 .167
 ; a0 14 50
 ; p1 p2 p3 p4 p5 p6 p7 p8 p9 p10
 ; Start Dur Amp Freq GrTab WinTab FqcRng Dens Fade
 ; i1 0.0 6.5 700 9.00 5 4 .210 200 1.8
 ; i1 3.2 3.5 800 7.08 . 4 .042 100 0.8
 ; i1 5.1 5.2 600 7.10 . 4 .0320 100 0.9
 ; i1 7.2 6.6 900 8.03 . 4 .021 150 1.6
 ; i1 21.3 4.5 1000 9.00 . 4 .031 150 1.2
 ; i1 26.5 13.5 1100 6.09 . 4 .121 150 1.5
 ; i1 30.7 9.3 900 8.05 . 4 .014 150 2.5
 ; i1 34.2 8.8 700 10.02 . 4 .14 150 1.6
igrtab ftgenonce 0, 0, 65536, 10, 1, .3, .1, 0, .2, .02, 0, .1, .04
iwintab ftgenonce 0, 0, 65536, 10, 1, 0, .5, 0, .33, 0, .25, 0, .2, 0, .167
iHz = ifrequency
ihertz = iHz
ip4 = iamplitude
ip5 = iHz
ip6 = igrtab
ip7 = iwintab
ip8 = 0.033
ip8 = .002
ip9 = 150
ip9 = 100
ip10 = 1.6
ip10 = 3
idur = p3
iamp = iamplitude ; p4
ifqc = iHz ; cpspch(p5)
igrtab = ip6
iwintab = ip7
ifrng = ip8
idens = ip9
ifade = ip10
igdur = 0.2
iattack = i(gk_overlap) * 2
idecay = i(gk_overlap) * 2
isustain = p3 - i(gk_overlap) * 2
p3 = iattack + isustain + idecay
kenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
; kamp linseg 0, ifade, 1, idur - 2 * ifade, 1, ifade, 0
kamp = kenvelope
; Amp Fqc Dense AmpOff PitchOff GrDur GrTable WinTable MaxGrDur
aoutl grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange,  gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aoutr grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aleft = aoutl * kamp * iamplitude
aright = aoutr * kamp * iamplitude
adamping linseg 0, 0.03, 1, p3 - 0.1, 1, 0.07, 0
aleft = adamping * aleft
aright = adamping * aright
kgain = ampdb(gk_Blower_level)
outleta "outleft", aleft * kgain
outleta "outright", aright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "Blower      i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_FM_Clang_preset init 1
instr FM_Clang_preset
gk_FM_Clang_preset chnget "gk_FM_Clang_preset"
gk_FM_Clang_preset_ int gk_FM_Clang_preset
ktrig changed gk_FM_Clang_preset_
#define SET_PRESET(N'Amp'AttTim'AttVel'Dur'Sustain'mod'NdxVel'NdxCurve'CarKyb'DtnMix'Detune'LPF'FiltFund'NseAmp'NseBW'NseFllw'ModMix'ModDep'ModRte'ModRteKyb'StMix'StWidth'RvbDryWet'RvbSize)
#
if i(gk_FM_Clang_preset_)==$N then
printks2 "Setting preset %d\n", $N
chnset $Amp ,"Amp"
chnset $AttTim ,"AttTim"
chnset $AttVel ,"AttVel"
chnset $Dur ,"Dur"
chnset $Sustain ,"Sustain"
chnset $mod ,"mod"
chnset $NdxVel ,"NdxVel"
chnset $NdxCurve ,"NdxCurve"
chnset $CarKyb ,"CarKyb"
chnset $DtnMix ,"DtnMix"
chnset $Detune ,"Detune"
chnset $LPF ,"LPF"
chnset $FiltFund ,"FiltFund"
chnset $NseAmp ,"NseAmp"
chnset $NseBW ,"NseBW"
chnset $NseFllw ,"NseFllw"
chnset $ModMix ,"ModMix"
chnset $ModDep ,"ModDep"
chnset $ModRte ,"ModRte"
chnset $ModRteKyb,"ModRteKyb"
chnset $StMix ,"StMix"
chnset $StWidth ,"StWidth"
chnset $RvbDryWet,"RvbDryWet"
chnset $RvbSize ,"RvbSize"
endif
#
if ktrig==1 then
reinit SEND_PRESET
endif
SEND_PRESET:
; N'Amp'AttTim'AttVel'Dur'Sustain'mod 'NdxVel'NdxCurve'CarKyb'DtnMix'Detune'LPF'FiltFund'NseAmp'NseBW'NseFllw'ModMix'ModDep'ModRte'ModRteKyb'StMix'StWidth'RvbDryWet'RvbSize)
$SET_PRESET(1'0.5'0 '0 '12 '1 '2.29'1 '16 '0 '1 '1.5 '16 '1 '1000 '0.001'0 '1 '0.1 '3 '0 '0.5 '0.01 '0.3 '0.55 )
$SET_PRESET(2'0.8'0 '0 '1.7'1 '5.04'0.55 '100 '0 '0 '0 '3.8'0 '0 '0.001'0 '0 '0.1 '3 '0 '0.5 '0.01 '0.1 '0.55 )
$SET_PRESET(3'0.5'0.1 '0.5 '3.8'1 '1.00'2 '28 '0 '1 '15 '16 '0 '500 '0.0077'1 '1 '0.1 '3 '0 '0.5 '0.01 '0.3 '0.55 )
$SET_PRESET(4'0.5'0 '0.006 '24 '1 '3.19'1 '15 '0 '0.47 '2.5 '16 '1 '0 '0.001'0 '1 '0.1 '0.33 '1.7 '0.5 '0.01 '0.3 '0.55 )
$SET_PRESET(5'0.8'0 '1 '6.6'0 '1.12'1 '13 '-2.68 '1 '25 '3.8'0 '0 '0.001'0 '0 '0.1 '3 '0 '1 '0.02 '0.172 '0.21 )
$SET_PRESET(6'3.25'0.1 '1 '1.28'0 '2.55'0.55 '35 '-2.3 '0 '1.5 '16 '1 '2000 '0.0025'0 '0 '0.1 '3 '0 '0.5 '0.01 '0.68 '0.93 )
$SET_PRESET(7'4 '0.1 '1 '2.39'1 '2.55'0.55 '35 '-2.3 '0 '1.5 '16 '1 '16 '0.1262'0 '0 '0.1 '3 '0 '0 '0.01 '1.00 '0 )
$SET_PRESET(8'1 '0 '0 '14.25'1 '6.97'0.55 '35 '-2.3 '0.13 '1.5 '4.78'1 '16 '0.0326'0 '1 '0.1 '3 '0 '0 '0.01 '0.6 '0 )
$SET_PRESET(9'1.65'0 '0 '1.7'1 '1.20'0.55 '100 '0 '0 '0 '3.8'0 '0 '0.001'0 '0 '0.1 '3 '0 '0.5 '0.01 '0.1 '0.55 )
$SET_PRESET(10'2' 0 '0 '1 '1 '2.15'0.55 '100 '0 '0.21 '12 '3.8'0 '0 '0.001'0 '0 '0.1 '3 '0 '0.5 '0.01 '0.35 '0.37 )
$SET_PRESET(11'2 '0.1 '1 '3.44'1 '3.75'0.55 '100 '0 '0.21 '25 '16 '0 '0 '0.001'1 '0 '0.1 '3 '0 '0.5 '0.05 '0 '0.37 )
$SET_PRESET(12'2 '0.1 '1 '1.45'1 '2.66'1.00 '16 '0 '0.21 '25 '16 '0 '0 '0.001'1 '0 '0.1 '3 '0 '0.5 '0.05 '0.6 '0.37 )
$SET_PRESET(13'1.9'0 '0 '24 '1 '2.29'1.00 '23.25 '-4 '1 '1.5 '16 '1 '151 '0.0178'1 '1 '0.1 '3 '0 '0.5 '0.01 '0.3 '0.55 )
endin

gk_Piano_level init .25
instr PianoOut
kgain = ampdb(gk_Piano_level)
giFluidsynth fluidEngine 0, 0
giFluidSteinway fluidLoad "Piano Steinway Grand Model C (21,738KB).sf2", giFluidsynth, 1
fluidProgramSelect giFluidsynth, 0, giFluidSteinway, 0, 1
i_instrument = p1
i_time = p2
i_duration = p3
i_midikey = p4
i_midivelocity = p5
aoutleft, aoutright fluidOut giFluidsynth
aoutleft = aoutleft * 5000000
aoutright = aoutright * 5000000
;printks "fluidOut: %9.4f %9.4f\n", 0.5, aoutleft, aoutright
outleta "outleft", aoutleft * kgain
outleta "outright", aoutright * kgain
;;;;;;;;;;;;;;;;;;;;i
prints "PianoOut    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

/**
 * Solina Chorus, based on Solina String Ensemble Chorus Module

   J. Haible: Triple Chorus
   http://jhaible.com/legacy/triple_chorus/triple_chorus.html

   Hugo Portillo: Solina-V String Ensemble
   http://www.native-instruments.com/en/reaktor-community/reaktor-user-library/entry/show/4525/

   Parabola tabled shape borrowed from Iain McCurdy delayStereoChorus.csd:
   http://iainmccurdy.org/CsoundRealtimeExamples/Delays/delayStereoChorus.csd

   Author: Steven Yi
   Date: 2016.05.22
   Adapted by Michael Gogins
*/
gi_solina_parabola ftgen 0, 0, 65537, 19, 0.5, 1, 180, 1
; 3 sine wave LFOs, 120 degrees out of phase
opcode sol_lfo_3, aaa, kk
kfreq, kamp xin
aphs phasor kfreq
; Funny: Function syntax does not work in this context.
a0   tablei aphs, gi_solina_parabola, 1, 0, 1
a120 tablei aphs, gi_solina_parabola, 1, 0.333, 1
a240 tablei aphs, gi_solina_parabola, 1, -0.333, 1
xout (a0 * kamp), (a120 * kamp), (a240 * kamp)
endop

opcode solina_chorus, a, akkkk
aLeft, klfo_freq1, klfo_amp1, klfo_freq2, klfo_amp2 xin
imax = 100
;; slow lfo
as1, as2, as3 sol_lfo_3 klfo_freq1, klfo_amp1
;; fast lfo
af1, af2, af3  sol_lfo_3 klfo_freq2, klfo_amp2
at1 = limit(as1 + af1 + 5, 0.0, imax)
at2 = limit(as2 + af2 + 5, 0.0, imax)
at3 = limit(as3 + af3 + 5, 0.0, imax)
a1 vdelay3 aLeft, at1, imax
a2 vdelay3 aLeft, at2, imax
a3 vdelay3 aLeft, at2, imax
xout (a1 + a2 + a3) / 3
endop

gk_SolinaChorus_chorus_lfo1_hz init .18
gk_SolinaChorus_chorus_lfo1_amp init .6
gk_SolinaChorus_chorus_lfo2_hz init 6
gk_SolinaChorus_chorus_lfo2_amp init .2
instr SolinaChorus
aleft inleta "inleft"
aright inleta "inright"
aleft solina_chorus aleft, gk_SolinaChorus_chorus_lfo1_hz, gk_SolinaChorus_chorus_lfo1_amp, gk_SolinaChorus_chorus_lfo2_hz, gk_SolinaChorus_chorus_lfo2_amp
aright solina_chorus aright, gk_SolinaChorus_chorus_lfo1_hz, gk_SolinaChorus_chorus_lfo1_amp, gk_SolinaChorus_chorus_lfo2_hz, gk_SolinaChorus_chorus_lfo2_amp
outleta "outleft", aleft
outleta "outright", aright
endin

gk_Reverb_Feedback init 0.975
gk_Delay_Modulation init 0.875

instr ReverbLeft
aleft init 0
azero init 0
aleft inleta "inleft"
aleft, aright reverbsc aleft, azero, gk_Reverb_Feedback, 15000.
outleta "outleft", aleft
;;;;;;;;;;;;;;;;;;;;i
prints "ReverbLeft  i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

instr ReverbRight
aleft init 0
azero init 0
aright inleta "inright"
aleft, aright reverbsc azero, aright, gk_Reverb_Feedback, 15000.0
outleta "outright", aright
;;;;;;;;;;;;;;;;;;;;i
prints "ReverbRight i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_Reverb2_Feedback init 0.975
gk_Delay2_Modulation init 0.875

instr Reverb2Left
aleft init 0
azero init 0
aleft inleta "inleft"
aleft, aright reverbsc aleft, azero, gk_Reverb2_Feedback, 15000.
outleta "outleft", aleft
;;;;;;;;;;;;;;;;;;;;i
prints "Reverb2Left i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

instr Reverb2Right
aleft init 0
azero init 0
aright inleta "inright"
aleft, aright reverbsc azero, aright, gk_Reverb2_Feedback, 15000.0
outleta "outright", aright
;;;;;;;;;;;;;;;;;;;;i
prints "Reverb2Righ i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_CenterHz init 200
gk_Gain init 1
gk_Q init 0.7071067 ; sqrt(.5)
instr ParametricEQ
aleft inleta "inleft"
aright inleta "inright"
aleft pareq aleft, gk_CenterHz, ampdb(gk_Gain), gk_Q, 0
aright pareq aright, gk_CenterHz, ampdb(gk_Gain), gk_Q, 0
outleta "outleft", aleft
outleta "outright", aright
;;;;;;;;;;;;;;;;;;;;i
prints "ParametrcEQ i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

gk_MasterOutput_level init .5
instr MasterOutput
aleft inleta "inleft"
aright inleta "inright"
kgain = ampdb(gk_MasterOutput_level)
; printks2 "Master gain: %f\n", kgain
iamp init 1
iattack init .01
idecay init 10
isustain = 2400 - (iattack + idecay)
aenvelope transeg 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
aright butterlp aright, 16000
aleft butterlp aleft, 16000
outs aleft * kgain * aenvelope, aright * kgain * aenvelope
idate date
itim     date
Stim     dates     itim
Syear    strsub    Stim, 20, 24
Smonth   strsub    Stim, 4, 7
Sday     strsub    Stim, 8, 10
iday     strtod    Sday
Shor     strsub    Stim, 11, 13
Smin     strsub    Stim, 14, 16
Ssec     strsub    Stim, 17, 19
Sfilename sprintf  "Sevier-6-%s_%s_%02d_%s_%s_%s.wav", Syear, Smonth, iday, Shor, Smin, Ssec
prints sprintf("Output filename: %s\n", Sfilename)
; fout Sfilename, 16, aleft, aright
;;;;;;;;;;;;;;;;;;;;i
prints "MasterOutpt i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

instr Controls
    gk_Bower_level chnget "gk_Bower_level"
    gk_Bower_pressure chnget "gk_Bower_pressure"
    gk_Blower_grainDensity chnget "gk_Blower_grainDensity"
    gk_Blower_grainDuration chnget "gk_Blower_grainDuration"
    gk_Blower_grainAmplitudeRange chnget "gk_Blower_grainAmplitudeRange"
    gk_Blower_grainFrequencyRange chnget "gk_Blower_grainFrequencyRange"
    gk_Blower_level chnget "gk_Blower_level"
    gk_Buzzer_harmonics chnget "gk_Buzzer_harmonics"
    gk_Buzzer_level chnget "gk_Buzzer_level"
    gk_Droner_partial1 chnget "gk_Droner_partial1"
    gk_Droner_partial2 chnget "gk_Droner_partial2"
    gk_Droner_partial3 chnget "gk_Droner_partial3"
    gk_Droner_partial4 chnget "gk_Droner_partial4"
    gk_Droner_partial5 chnget "gk_Droner_partial5"
    gk_Droner_level chnget "gk_Droner_level"
    gk_Harpsichord_level chnget "gk_Harpsichord_level"
    gk_Harpsichord_pick chnget "gk_Harpsichord_pick"
    gk_Harpsichord_reflection chnget "gk_Harpsichord_reflection"
    gk_Harpsichord_pluck chnget "gk_Harpsichord_pluck"
    gk_MasterOutput_level chnget "gk_MasterOutput_level"
    gk_Phaser_ratio1 chnget "gk_Phaser_ratio1"
    gk_Phaser_ratio2 chnget "gk_Phaser_ratio2"
    gk_Phaser_index1 chnget "gk_Phaser_index1"
    gk_Phaser_index2 chnget "gk_Phaser_index2"
    gk_Phaser_level chnget "gk_Phaser_level"
    gk_Piano_level chnget "gk_Piano_level"
    gk_Shiner_level chnget "gk_Shiner_level"
    gk_Sweeper_britel chnget "gk_Sweeper_britel"
    gk_Sweeper_briteh chnget "gk_Sweeper_briteh"
    gk_Sweeper_britels chnget "gk_Sweeper_britels"
    gk_Sweeper_britehs chnget "gk_Sweeper_britehs"
    gk_Sweeper_level chnget "gk_Sweeper_level"
    gk_YiString_reverb_send chnget "gk_YiString_reverb_send"
    gk_YiString_cbhorus_send chnget "gk_YiString_cbhorus_send"
    gk_YiString_level chnget "gk_YiString_level"
    ;gk_SolinaChorus_chorus_lfo1_hz init .18
    ;gk_SolinaChorus_chorus_lfo1_amp init .6
    ;gk_SolinaChorus_chorus_lfo2_hz init 6
    ;gk_SolinaChorus_chorus_lfo2_amp init .2
    gk_Reverb_Feedback chnget "gk_Reverb_Feedback"
    gk_Reverb2_Feedback chnget "gk_Reverb2_Feedback"
    gk_overlap chnget "gk_overlap"
;;;;;;;;;;;;;;;;;;;;i
prints "Controls    i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
endin

instr 999
;;;;;;;;;;;;;;;;;;;;i
prints "StopPerform i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f\n", p1, p2, p3, p4, p5, p7
exitnow
endin
    </textarea>
    <script>
        window.onerror = function (text, url, line) {
          csound.message(text + '\n' + url + '\n' + line + '\n');
          console.trace();
        }
        var graphics_canvas = document.getElementById('graphics_canvas');
        var score = new Silencio.Score();
        var function_for_time = null;
        var function_for_pitch = null;
        var mapping_for_time = null;
        var mapping_for_pitch = null;
        var simplified_for_time = null;
        var simplified_for_pitch = null;
        function onWindowResize( event ) {
            windowHalfX = graphics_canvas.clientWidth / 2;
            camera.aspect = graphics_canvas.clientWidth / graphics_canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(graphics_canvas.clientWidth, graphics_canvas.clientHeight );
        }
        var title = 'Symbolic_Spirograph';
        var startTime = 0;
        function csoundMessage(text) {
            var Log_cell = document.getElementById('Log_cell');
            Log_cell.value += text;
            console.log(text);
            Log_cell.scrollTop = Log_cell.scrollHeight;
         }
        function onWindowResize( event ) {
            var container = document.getElementById('webgl_cell');
            windowHalfX = container.clientWidth / 2;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( container.clientWidth, container.clientHeight );
        }
        function handleMessage(message) {
            csoundMessage(message);
        }
        function updateSystem() {
            var score_time = csound.getScoreTime();
            if (typeof score_time !== 'undefined') {
                var score_time_cell = document.getElementById('Time_cell');
                score_time_cell.innerHTML = score_time.toFixed(4);
            }
            setTimeout(updateSystem, .02);
            score.progress3D(score_time);
        };
        var timeout_function = null;
        var parameters = {
            gk_Bower_pressure: 0.25,
            gk_Bower_level: 0.5,
            gk_Blower_grainDensity: .150,
            gk_Blower_grainDuration: .2,
            gk_Blower_grainAmplitudeRange: .1,
            gk_Blower_grainFrequencyRange: .033,
            gk_Blower_level: 0.5,
            gk_Buzzer_Harmonics: 15,
            gk_Buzzer_level: 0.5,
            gk_Droner_partial1: 0.1,
            gk_Droner_partial2: 0.1,
            gk_Droner_partial3: 0.1,
            gk_Droner_partial4: 0.1,
            gk_Droner_partial5: 0.1,
            gk_Droner_level: 0.5,
            gk_Harpsichord_level: 0.5,
            gk_Harpsichord_pick: .75,
            gk_Harpsichord_reflection: .5,
            gk_Harpsichord_pluck: .75,
            gk_Phaser_ratio1: 1,
            gk_Phaser_ratio2: .3333334,
            gk_Phaser_index1: 1,
            gk_Phaser_index2: .0125,
            gk_Phaser_level: 0.5,
            gk_Piano_level: 0.5,
            gk_Shiner_level: 0.5,
            gk_Sweeper_britel: 0,
            gk_Sweeper_briteh: 2.9,
            gk_Sweeper_britels: .2 / 3,
            gk_Sweeper_britehs: 2.5 / 2,
            gk_Sweeper_level: 0.5,
            gk_YiString_reverb_send: 0.5,

            gk_YiString_chorus_send: 0.5,
            gk_YiString_level: 0.5,
            gk_SolinaChorus_chorus_lfo1_hz: 18,
            gk_SolinaChorus_chorus_lfo1_amp: .6,
            gk_SolinaChorus_chorus_lfo2_hz: 6,
            gk_SolinaChorus_chorus_lfo2_amp: .2,
            gk_Reverb_Feedback: .975,
            gk_Reverb2_Feedback: .7,
            gk_MasterOutput_level: .4,
            gk_overlap: 0.05,
            gk_FM_Clang_preset: 1,
            gk_FM_Clang_level: 0,

            Theta_increment: 0.01,
            Note_count: 800,
            Duration_seconds: 240,
            R: 12,
            r: .92,
            p: .5,
            Lowest_note: 36,
            Range: 60,
            Duration_factor: 4,
            Play: function() {
                csound.stop();
                try {
                    csound.setMessageCallback(csoundMessage);
                } catch(e) {
                    console.log(e);
                }
                generate();
                score.draw3D(graphics_canvas);
                csound.compileOrc(document.getElementById('orc').value);
                csound.setOption('-m0');
                csound.setOption('-j3');
                csound.setOption('--nodisplays');
                csound.setOption('-odac');
                gui.revert();
                csound.perform();
                start_time_seconds = new Date().getTime() / 1000.0;
                startTime = csound.getScoreTime();
                timeout_function = setTimeout(updateSystem, 0);
            },
            Developer_tools: function() {
                nwgui.Window.get().showDevTools();
            },
            Stop: function() {
                csound.stop();
                clearTimeout(timeout_function);
            },
            Close: function() {
                try {
                    csound.stop();
                    window.close();
                } catch (e) {
                    console.log(e);
                }
            }
        };
        function generate() {
            score.clear();
            var t = 0;
            var R = parameters.R;
            var r = parameters.r;
            var p = parameters.p;
            // We must ensure that the spirograph is entirely bounded by the unit disc,
            // otherwise the disc to square mapping will give coordinates with imaginary parts.
            var R_max = R + r + p;
            R = R / R_max;
            r = r / R_max;
            p = p / R_max;
            for (var i = 0; i < parameters.Note_count; i++) {
                // To reliably get actual numbers, 3 steps are required: eval, float, and Number.
                var u = Algebrite.eval(function_for_pitch,  'R', R, 'r', r, 'p', p, 'theta', t);
                u = Algebrite.float(u);
                u = Number(u);
                var v = Algebrite.eval(function_for_time,  'R', R, 'r', r, 'p', p, 'theta', t);
                v = Algebrite.float(v);
                v = Number(v);
                var x = Algebrite.eval(mapping_for_time, 'u', u, 'v', v);
                x = Algebrite.float(x);
                x = Number(x);
                var y = Algebrite.eval(mapping_for_pitch, 'u', u, 'v', v);
                y = Algebrite.float(y);
                y = Number(y);
                var p0_time = x;
                var p1_duration = parameters.Duration_factor;
                var p2_status = 144;
                var p3_channel = (i % 5) + 2;
                var p4_key = y;
                var p5_velocity = 60;
                score.add(p0_time, p1_duration, p2_status, p3_channel, p4_key, p5_velocity);
                // Roll the little wheel.
                t += parameters.Theta_increment;
            }
            // Rescale and otherwise massage the score.
            score.findScales();
            csound.message(score.getDuration().toString() + '\n');
            score.sort();
            //score.setScale(3, 2, 9.9);
            score.setScale(4, parameters.Lowest_note, parameters.Range);
            score.temper(12);
            score.setScale(5, 60, 10);
            score.setScale(6, .4, .6);
            score.setScale(7, .4, .6);
            ///score.tieOverlaps(true);
            ///conformToChords();
            score.setDuration(parameters.Duration_seconds);
            score.setScale(1, 1, 5);
            csound.message('Cleaning up some annoying things in the score...');
            for (var i = 0; i < score.data.length; i++) {
                var event = score.data[i];
                // We didn't generate pan, so just randomize it.
                var pan = Math.random() * 2 - 1;
                event.pan = pan;
            }
            // Pianoteq misbehaves if we start right at time 0.
            for (var i = 0; i < score.data.length; i++) {
                var event = score.data[i];
                event.time = event.time + 1;
            }
            // Also if keys overlap.
            for (var i = 0; i < score.data.length; i++) {
                var event = score.data[i];
                console.log(event.toIStatement() + ' e: ' + event.end);
                var channel = Math.floor(event.channel);
                var key = event.key;
                for (var j = i + 1; j < score.data.length; j++) {
                    var overlap = score.data[j];
                    var overlap_channel = Math.floor(overlap.channel);
                    var overlap_key = overlap.key;
                    if (key === overlap_key && channel === overlap_channel && channel === 2) {
                        if (event.end > overlap.time) {
                            var the_end = Math.max(event.end, overlap.end);
                            console.log('Correcting overlap for:');
                            console.log('  ' + event.toIStatement() + ' e: ' + event.end);
                            console.log('  ' + overlap.toIStatement() + ' e: ' + overlap.end);
                            event.end = the_end;
                            overlap.end = the_end;
                            console.log('to:');
                            console.log('  ' + event.toIStatement() + ' e: ' + event.end);
                            console.log('  ' + overlap.toIStatement() + ' e: ' + overlap.end + '\n');
                         }
                    }
                }
             }
            var panskip = .05;
            var leftpan = panskip / 2;
            var panrange = 1 - panskip;
            score.setScale(6, leftpan, panrange);
            score.setScale(7, leftpan, panrange);
            score.draw3D(graphics_canvas);
            score.sendToCsound(csound);
        }
        var gui = null;
        window.onload = function() {
            //csound.message('platform: ' + navigator.platform + '\n');
            //var gui = new dat.GUI({load: json, width: 300});
            gui = new dat.GUI({width: 300});
            gui.remember(parameters);
            gui.add(parameters, 'Play').name('Play');
            gui.add(parameters, 'Stop').name('Stop');
            gui.add(parameters, 'Developer_tools').name('Debugger');
            gui.add(parameters, 'Close').name('Close');
            var Dynamical_Systems = gui.addFolder('Spirograph');
            add_slider(Dynamical_Systems, 'R', 0, 1);
            add_slider(Dynamical_Systems, 'r', 0, 1);
            add_slider(Dynamical_Systems, 'p', 0, 1);
            add_slider(Dynamical_Systems, 'Theta_increment', 0, 4);
            add_slider(Dynamical_Systems, 'Note_count', 12, 4000);
            add_slider(Dynamical_Systems, 'Duration_seconds', 30, 600);
            add_slider(Dynamical_Systems, 'Duration_factor', .125, 8);
            add_slider(Dynamical_Systems, 'Lowest_note', 12, 72);
            add_slider(Dynamical_Systems, 'Range', 12, 72);
            var Master = gui.addFolder('Master effects');
            add_slider(Master, 'gk_overlap', 0, 20);
            add_slider(Master, 'gk_Reverb_Feedback', 0, 1);
            add_slider(Master, 'gk_Reverb2_Feedback', 0, 1);
            add_slider(Master, 'gk_MasterOutput_level', -40, 40);
            var intruments = gui.addFolder('Instruments');
            var fmclang = intruments.addFolder('FM Clang');
            add_slider(fmclang, 'gk_FM_Clang_preset', 1, 13);
            add_slider(fmclang, 'gk_FM_Clang_level', -40, 40);
            var Blower = intruments.addFolder('Blower');
            add_slider(Blower, 'gk_Blower_grainDensity', 0, 400);
            add_slider(Blower, 'gk_Blower_grainDuration', 0, .5);
            add_slider(Blower, 'gk_Blower_grainAmplitudeRange', 0, 400);
            add_slider(Blower, 'gk_Blower_grainFrequencyRange', 0, 100);
            add_slider(Blower, 'gk_Blower_level', -40, 40);
            var Bower = intruments.addFolder('Bower');
            add_slider(Bower, 'gk_Bower_pressure', 0, 1);
            add_slider(Bower, 'gk_Bower_level', -40, 40);
            var Buzzer = intruments.addFolder('Buzzer');
            add_slider(Buzzer, 'gk_Buzzer_Harmonics', 0, 20);
            add_slider(Buzzer, 'gk_Buzzer_level', -40, 40);
            var Droner = intruments.addFolder('Droner');
            add_slider(Droner, 'gk_Droner_partial1', 0, 1);
            add_slider(Droner, 'gk_Droner_partial2', 0, 1);
            add_slider(Droner, 'gk_Droner_partial3', 0, 1);
            add_slider(Droner, 'gk_Droner_partial4', 0, 1);
            add_slider(Droner, 'gk_Droner_partial5', 0, 1);
            add_slider(Droner, 'gk_Droner_level', -40, 40);
            var Harpsichord = intruments.addFolder('Harpsichord');
            add_slider(Harpsichord, 'gk_Harpsichord_pick', 0, 1);
            add_slider(Harpsichord, 'gk_Harpsichord_reflection', .000001, .999999);
            add_slider(Harpsichord, 'gk_Harpsichord_pluck', 0, 1);
            add_slider(Harpsichord, 'gk_Harpsichord_level', -40, 40);
            var Phaser = intruments.addFolder('Phaser');
            add_slider(Phaser, 'gk_Phaser_ratio1', 0, 2);
            add_slider(Phaser, 'gk_Phaser_ratio2', 0, 2);
            add_slider(Phaser, 'gk_Phaser_index1', 0, 1);
            add_slider(Phaser, 'gk_Phaser_index2', 0, 1);
            add_slider(Phaser, 'gk_Phaser_level', -40, 40);
            var Piano = intruments.addFolder('Piano');
            add_slider(Piano, 'gk_Piano_level', -40, 40);
            var Shiner = intruments.addFolder('Shiner');
            add_slider(Shiner, 'gk_Shiner_level', -40, 40);
            var Sweeper = intruments.addFolder('Sweeper');
            add_slider(Sweeper, 'gk_Sweeper_britel', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_briteh', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_britels', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_britehs', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_level', -40, 40);
            var YiString = intruments.addFolder('YiString');
            add_slider(YiString, 'gk_YiString_reverb_send', 0, 1);
            add_slider(YiString, 'gk_YiString_chorus_send', 0, 1);
            add_slider(YiString, 'gk_YiString_level', -40, 40);
            gui.revert();
            // Set up the Algebrite expressions for the spirograph.
            Algebrite.run('w = (R + r) * cos(theta) + p * cos((R + r) * theta / r)');
            Algebrite.run('z = (R + r) * sin(theta) + p * sin((R + r) * theta / r)');
            function_for_time  = Algebrite.eval('w');
            function_for_pitch = Algebrite.eval('z');

            // I would have liked to try a true conformal mapping, but Algebrite can't solve the following definite integral:
            // Algebrite.run('K_e = defint(d(t) / sqrt(1 - 1/2 sin^2 t), t, 0, 1/2 pi)');
            // var K_e = Algebrite.eval('K_e')
            // var K = Algebrite.float(K_e);

            // Set up the Algebrite expressions for mapping the spirograph to a square.
            Algebrite.run('x = 1 / 2 (sqrt(2 + u^2 - v^2 + 2 sqrt(2) u)) - 1 / 2 (sqrt(2 + u^2 - v^2 - 2 sqrt(2) u))');
            mapping_for_time = Algebrite.eval('x')
            Algebrite.run('y = 1 / 2 (sqrt(2 - u^2 + v^2 + 2 sqrt(2) v)) - 1 / 2 (sqrt(2 - u^2 + v^2 - 2 sqrt(2) v))');
            mapping_for_pitch = Algebrite.eval('y')
            document.getElementById('eq_1').innerHTML = '$$u = ' + function_for_time.toLatexString() + '$$ <br> $$v = ' + function_for_pitch.toLatexString() + '.$$';
            document.getElementById('eq_2').innerHTML = '$$x = ' + mapping_for_time.toLatexString() + '$$ <br> $$y = ' + mapping_for_pitch.toLatexString() + '.$$';
        }
        function gk_update(name, value) {
          console.log(name + ': ' + value);
          if (name === 'Note_count') {
            parameters.Note_count = parseFloat(value);
          } else if (name === 'Duration_seconds') {
            parameters.Duration_seconds = parseFloat(value);
          } else if (name === 'Theta_increment') {
            parameters.Theta_increment = parseFloat(value);
         } else if (name === 'R') {
            parameters.R = parseFloat(value);
          } else if (name === 'r') {
            parameters.r = parseFloat(value);
          } else if (name === 'p') {
            parameters.p = value;
          } else if (name == 'Lowest_note') {
            parameters.Lowest_note = parseFloat(value);
          } else if (name == 'Range') {
            parameters.Range = parseFloat(value);
          } else if (name == 'Duration_factor') {
            parameters.Duration_factor = parseFloat(value);
          } else {
              var numberValue = parseFloat(value);
              csound.setControlChannel(name, numberValue);
          }
          csound.message(name + ': ' + value + '\n');
        }
        function add_slider(gui_folder, token, minimum, maximum) {
            var on_parameter_change = function(value) {
                gk_update(token, value);
            };
            var slider = gui_folder.add(parameters, token, minimum, maximum);
            slider.onChange(on_parameter_change);
            return slider;
        };
       </script>
    </body>
</html>
